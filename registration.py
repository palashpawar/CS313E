"""
Student information for this assignment:

On my honor, Palash, this
programming assignment is my own work and I have not provided this code to
any other student.

I have read and understand the course syllabus's guidelines regarding Academic
Integrity. I understand that if I violate the Academic Integrity policy (e.g.
copy code from someone else, have the code generated by an LLM, or give my
code to someone else), the case shall be submitted to the Office of the Dean of
Students. Academic penalties up to and including an F in the course are likely.

UT EID 1: ppp625
"""

import sys

class HeapError(Exception):
    """Custom exception class for heap errors."""
    pass

class BinaryHeap:
    """A modified binary heap implementation from the readings."""

    def __init__(self):
        self.__heap = []

    def _perc_up(self, i):
        while (i - 1) // 2 >= 0:
            parent_idx = (i - 1) // 2
            if self.__heap[i] < self.__heap[parent_idx]:
                self.__heap[i], self.__heap[parent_idx] = (
                    self.__heap[parent_idx],
                    self.__heap[i],
                )
            i = parent_idx

    def insert(self, item):
        self.__heap.append(item)
        self._perc_up(len(self.__heap) - 1)

    def _perc_down(self, i):
        while 2 * i + 1 < len(self.__heap):
            sm_child = self._get_min_child(i)
            if self.__heap[i] > self.__heap[sm_child]:
                self.__heap[i], self.__heap[sm_child] = (
                    self.__heap[sm_child],
                    self.__heap[i],
                )
            else:
                break
            i = sm_child

    def _get_min_child(self, i):
        if 2 * i + 2 > len(self.__heap) - 1:
            return 2 * i + 1
        if self.__heap[2 * i + 1] < self.__heap[2 * i + 2]:
            return 2 * i + 1
        return 2 * i + 2

    def delete(self):
        if self.is_empty():
            raise HeapError("Heap is empty")
        self.__heap[0], self.__heap[-1] = self.__heap[-1], self.__heap[0]
        result = self.__heap.pop()
        self._perc_down(0)
        return result

    def peek(self):
        if self.is_empty():
            raise IndexError("Heap is empty")
        return self.__heap[0]

    def is_empty(self):
        return len(self.__heap) == 0

    def heapify(self, not_a_heap):
        self.__heap = not_a_heap[:]
        i = len(self.__heap) // 2 - 1
        while i >= 0:
            self._perc_down(i)
            i -= 1

class Node:
    """Singly-linked list node."""
    def __init__(self, data, link=None):
        self.data = data
        self.next = link

    @property
    def next(self):
        return self.__next

    @next.setter
    def next(self, value):
        if value is None or isinstance(value, Node):
            self.__next = value
        else:
            raise ValueError("Next must be a Node instance or None.")

class StackError(Exception):
    """Custom exception class for stack errors."""
    pass

class Stack:
    """Stack implemented via a singly linked list."""
    def __init__(self):
        self._top = None
        self._size = 0

    def peek(self):
        if self.is_empty():
            raise StackError("Peek from empty stack.")
        return self._top.data

    def push(self, item):
        new_node = Node(item)
        new_node.next = self._top
        self._top = new_node
        self._size += 1

    def pop(self):
        if self.is_empty():
            raise StackError("Pop from empty stack.")
        removed = self._top.data
        self._top = self._top.next
        self._size -= 1
        return removed

    def is_empty(self):
        return self._top is None

    def size(self):
        return self._size

class Vertex:
    """Vertex for a directed graph, with visited flag and depth."""
    def __init__(self, label):
        self.__label = label
        self.visited = False
        self.depth = -1

    @property
    def visited(self):
        return self.__visited

    @visited.setter
    def visited(self, val):
        if isinstance(val, bool):
            self.__visited = val
        else:
            raise ValueError("Visited must be a boolean")

    @property
    def depth(self):
        return self.__depth

    @depth.setter
    def depth(self, val):
        if isinstance(val, int):
            self.__depth = val
        else:
            raise ValueError("Depth must be an integer")

    @property
    def label(self):
        return self.__label

    def __str__(self):
        return str(self.__label)

class Graph:
    """Directed graph using an adjacency matrix."""
    def __init__(self):
        self.vertices = []
        self.adjacency_matrix = []

    def has_vertex(self, label):
        return any(v.label == label for v in self.vertices)

    def get_index(self,	label):
        for i, v in enumerate(self.vertices):
            if v.label == label:
                return i
        return -1

    def add_vertex(self, label):
        if self.has_vertex(label):
            return
        self.vertices.append(Vertex(label))
        for row in self.adjacency_matrix:
            row.append(0)
        self.adjacency_matrix.append([0] * len(self.vertices))

    def add_edge(self, start, finish):
        self.adjacency_matrix[start][finish] = 1

    def get_adjacent_vertices(self, idx):
        return [j for j, val in enumerate(self.adjacency_matrix[idx]) if val]

    def has_cycle(self):
        n = len(self.vertices)
        status = [0] * n  # 0=unvisited,1=visiting,2=done

        def dfs(u):
            status[u] = 1
            for v in self.get_adjacent_vertices(u):
                if status[v] == 1:
                    return True
                if status[v] == 0 and dfs(v):
                    return True
            status[u] = 2
            return False

        for i in range(n):
            if status[i] == 0:
                if dfs(i):
                    return True
        return False

    def compute_depth(self):
        def dfs_depth(u):
            if self.vertices[u].depth >= 0:
                return self.vertices[u].depth
            children = self.get_adjacent_vertices(u)
            if not children:
                self.vertices[u].depth = 0
            else:
                self.vertices[u].depth = 1 + max(dfs_depth(v) for v in children)
            return self.vertices[u].depth

        for i in range(len(self.vertices)):
            if self.vertices[i].depth < 0:
                dfs_depth(i)

    def get_registration_plan(self):
        n = len(self.vertices)
        indegree = [0] * n
        for u in range(n):
            for v in self.get_adjacent_vertices(u):
                indegree[v] += 1

        available = [i for i in range(n) if indegree[i] == 0]
        plan = []

        while available:
            # pick up to 4 by descending depth (ties preserve insertion order)
            available.sort(key=lambda i: self.vertices[i].depth, reverse=True)
            this_sem = available[:4]
            plan.append([self.vertices[i].label for i in this_sem])
            next_avail = available[4:]
            for u in this_sem:
                for v in self.get_adjacent_vertices(u):
                    indegree[v] -= 1
                    if indegree[v] == 0:
                        next_avail.append(v)
            available = next_avail

        return plan


def main():
    graph = Graph()
    data = sys.stdin.read().split()
    it = iter(data)
    try:
        n = int(next(it))
    except StopIteration:
        return
    for _ in range(n):
        graph.add_vertex(next(it))
    m = int(next(it))
    for _ in range(m):
        u_label = next(it)
        v_label = next(it)
        u = graph.get_index(u_label)
        v = graph.get_index(v_label)
        graph.add_edge(u, v)

    if graph.has_cycle():
        print("Registration plan invalid because a cycle was detected.")
    else:
        print("Valid registration plan detected.")
        graph.compute_depth()
        plan = graph.get_registration_plan()
        print()
        print("Registration plan: ")
        for sem in plan:
            print(sem)

if __name__ == "__main__":
    main()
