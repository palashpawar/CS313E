"""
Student information for this assignment:

On my honor, Palash, this
programming assignment is my own work and I have not provided this code to
any other student.

I have read and understand the course syllabus's guidelines regarding Academic
Integrity. I understand that if I violate the Academic Integrity policy (e.g.
copy code from someone else, have the code generated by an LLM, or give my
code to someone else), the case shall be submitted to the Office of the Dean of
Students. Academic penalties up to and including an F in the course are likely.

UT EID 1: ppp625
"""


class HeapError(Exception):
    """Custom exception class for heap errors."""
    pass

class BinaryHeap:
    """A modified binary heap implementation from the readings."""

    def __init__(self):
        """
        Initializes an empty binary heap.
        """
        self.__heap = []

    def _perc_up(self, i):
        """
        Moves the element at index i up to its correct position in the heap.
        """
        while (i - 1) // 2 >= 0:
            parent_idx = (i - 1) // 2
            if self.__heap[i] < self.__heap[parent_idx]:
                self.__heap[i], self.__heap[parent_idx] = (
                    self.__heap[parent_idx],
                    self.__heap[i],
                )
            i = parent_idx

    def insert(self, item):
        """
        Inserts a new item into the heap and maintains the heap property.
        """
        self.__heap.append(item)
        self._perc_up(len(self.__heap) - 1)

    def _perc_down(self, i):
        """
        Moves the element at index i down to its correct position in the heap."""
        while 2 * i + 1 < len(self.__heap):
            sm_child = self._get_min_child(i)
            if self.__heap[i] > self.__heap[sm_child]:
                self.__heap[i], self.__heap[sm_child] = (
                    self.__heap[sm_child],
                    self.__heap[i],
                )
            else:
                break
            i = sm_child

    def _get_min_child(self, i):
        """
        Returns the index of the smaller child of the node at index i.
        """
        if 2 * i + 2 > len(self.__heap) - 1:
            return 2 * i + 1
        if self.__heap[2 * i + 1] < self.__heap[2 * i + 2]:
            return 2 * i + 1
        return 2 * i + 2

    def delete(self):
        """
        Removes and returns the smallest item from the heap."""
        if self.is_empty():
            raise HeapError("Heap is empty")
        self.__heap[0], self.__heap[-1] = self.__heap[-1], self.__heap[0]
        result = self.__heap.pop()
        if self.__heap:  # Only perc_down if heap is not empty
            self._perc_down(0)
        return result

    def peek(self):
        """
        Returns the smallest item from the heap without removing it.
        """
        if self.is_empty():
            raise IndexError("Heap is empty")
        return self.__heap[0]

    def is_empty(self):
        """
        Checks if the heap is empty."""
        return len(self.__heap) == 0

    def heapify(self, not_a_heap):
        """
        Converts a list into a heap in O(n) time."""
        self.__heap = not_a_heap[:]
        i = len(self.__heap) // 2 - 1
        while i >= 0:
            self._perc_down(i)
            i = i - 1

class Node:
    """
    Represents a node in a singly linked list.
    """
    def __init__(self, data, link=None):
        self.data = data
        self.next = link

    @property
    def next(self):
        return self.__next

    @next.setter
    def next(self, value):
        if value is None or isinstance(value, Node):
            self.__next = value
        else:
            raise ValueError("Next must be a Node instance or None.")

class StackError(Exception):
    """Custom exception class for stack errors."""
    pass

class Stack:
    """
    A class that implements a stack using a singly linked list.
    """
    def __init__(self):
        self._top = None
        self._size = 0

    def peek(self):
        if self.is_empty():
            raise StackError("Peek from empty stack.")
        return self._top.data

    def push(self, item):
        new_node = Node(item)
        new_node.next = self._top
        self._top = new_node
        self._size += 1

    def pop(self):
        if self.is_empty():
            raise StackError("Pop from empty stack.")
        removed_data = self._top.data
        self._top = self._top.next
        self._size -= 1
        return removed_data

    def is_empty(self):
        return self._top is None

    def size(self):
        return self._size

class Vertex:
    """Vertex Class using properties and setters for better encapsulation."""
    def __init__(self, label):
        self.__label = label
        self.visited = False
        self.depth = -1

    @property
    def visited(self):
        return self.__visited

    @visited.setter
    def visited(self, value):
        if isinstance(value, bool):
            self.__visited = value
        else:
            raise ValueError("Visited status must be a boolean value.")

    @property
    def depth(self):
        return self.__depth

    @depth.setter
    def depth(self, value):
        if isinstance(value, int):
            self.__depth = value
        else:
            raise ValueError("Depth must be a integer value.")

    @property
    def label(self):
        return self.__label

    def __str__(self):
        return str(self.__label)

class Graph:
    """A Class to represent a Graph."""
    def __init__(self):
        self.vertices = []
        self.adjacency_matrix = []

    def has_vertex(self, label):
        for i in range(len(self.vertices)):
            if label == self.vertices[i].label:
                return True
        return False

    def get_index(self, label):
        for i in range(len(self.vertices)):
            if label == self.vertices[i].label:
                return i
        return -1

    def add_vertex(self, label):
        if self.has_vertex(label):
            return
        self.vertices.append(Vertex(label))
        num_vertices = len(self.vertices)
        for i in range(num_vertices - 1):
            self.adjacency_matrix[i].append(0)
        new_row = [0] * num_vertices
        self.adjacency_matrix.append(new_row)

    def add_edge(self, start, finish):
        self.adjacency_matrix[start][finish] = 1

    def get_adjacent_vertices(self, vertex_index):
        vertices = []
        for j in range(len(self.vertices)):
            if self.adjacency_matrix[vertex_index][j]:
                vertices.append(j)
        return vertices

    def compute_depth(self):
        """Computes depth for each vertex in the graph."""
        for vertex in self.vertices:
            vertex.visited = False
            vertex.depth = -1

        def dfs(v_idx, depth):
            vertex = self.vertices[v_idx]
            if vertex.visited:
                return
            vertex.visited = True
            vertex.depth = depth
            for adj in self.get_adjacent_vertices(v_idx):
                dfs(adj, depth + 1)

        for i in range(len(self.vertices)):
            if not self.vertices[i].visited:
                dfs(i, 0)

    def has_cycle(self):
        """
        Determine whether or not the graph has a cycle.
        post: returns True if there is a cycle, False otherwise.
        """
        for vertex in self.vertices:
            vertex.visited = False

        rec_stack = set()

        def dfs(v_idx):
            vertex = self.vertices[v_idx]
            if v_idx in rec_stack:
                return True  # Cycle detected
            if vertex.visited:
                return False
            vertex.visited = True
            rec_stack.add(v_idx)
            for adj in self.get_adjacent_vertices(v_idx):
                if dfs(adj):
                    return True
            rec_stack.remove(v_idx)
            return False

        for i in range(len(self.vertices)):
            if not self.vertices[i].visited:
                if dfs(i):
                    return True
        return False

    def get_registration_plan(self):
        """
        Return a valid ordering of courses to take for registration as a 2D
        list of vertex labels, where each inner list will have a maximum of 4 vertices.
        pre: a valid registration plan exists.
        post: returns a 2D list of strings, where each inner list represents a semester
        """
        if not self.vertices:
            return []

        self.compute_depth()
        
        # Create a list of (vertex_index, depth, label) tuples
        vertex_info = [(i, v.depth, v.label) for i, v in enumerate(self.vertices)]
        # Sort by depth first, then by label lexicographically
        vertex_info.sort(key=lambda x: (x[1], x[2]))
        
        # Group vertices into semesters
        semesters = []
        current_semester = []
        current_depth = vertex_info[0][1]
        
        for v_idx, depth, _ in vertex_info:
            if depth > current_depth and current_semester:
                semesters.append([self.vertices[i].label for i in current_semester])
                current_semester = []
                current_depth = depth
            if len(current_semester) < 4:
                current_semester.append(v_idx)
            else:
                semesters.append([self.vertices[i].label for i in current_semester])
                current_semester = [v_idx]
                current_depth = depth
        
        if current_semester:
            semesters.append([self.vertices[i].label for i in current_semester])
        
        return semesters

def main():
    """
    The main function to retrieve a registration plan.
    """
    graph = Graph()
    num_vertices = int(input())
    for _ in range(num_vertices):
        vertex_label = input().strip()
        graph.add_vertex(vertex_label)
    num_edges = int(input())
    for _ in range(num_edges):
        start_label, end_label = input().strip().split()
        start_idx = graph.get_index(start_label)
        end_idx = graph.get_index(end_label)
        graph.add_edge(start_idx, end_idx)

    if graph.has_cycle():
        print("Registration plan invalid because a cycle was detected.")
    else:
        print("Valid registration plan detected.")
        print()
        print("Registration plan: ")
        courses = graph.get_registration_plan()
        for semester in courses:
            print(semester)

if __name__ == "__main__":
    main()