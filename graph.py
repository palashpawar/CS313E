"""
Student information for this assignment:

On my honor, Palash, this
programming assignment is my own work and I have not provided this code to
any other student.

I have read and understand the course syllabus's guidelines regarding Academic
Integrity. I understand that if I violate the Academic Integrity policy (e.g.
copy code from someone else, have the code generated by an LLM, or give my
code to someone else), the case shall be submitted to the Office of the Dean of
Students. Academic penalties up to and including an F in the course are likely.

UT EID 1: ppp625
"""

import sys

# -----------------------PRINTING LOGIC, DON'T WORRY ABOUT THIS PART----------------------------
RESET_CHAR = "\u001b[0m"  # Code to reset the terminal color
COLOR_DICT = {
    "black": "\u001b[30m",
    "red": "\u001b[31m",
    "green": "\u001b[32m",
    "yellow": "\u001b[33m",
    "blue": "\u001b[34m",
    "magenta": "\u001b[35m",
    "cyan": "\u001b[36m",
    "white": "\u001b[37m",
}
BLOCK_CHAR = "\u2588"  # Character code for a block


def colored(text, color):
    """Wrap the string with the color code."""
    color = color.strip().lower()
    if color not in COLOR_DICT:
        raise ValueError(color + " is not a valid color!")
    return COLOR_DICT[color] + text


def print_block(color):
    """Print a block in the specified color."""
    print(colored(BLOCK_CHAR, color) * 2, end="")

# ----------------------------------------------------------------------------------------------


class Node:
    """
    Represents a node in a singly linked list.

    Instance Variables:
        data: The value or data stored in the node.
        next: The reference to the next node in the linked list (None by default).
    """

    def __init__(self, data, next=None):
        self.data = data
        self.next = next


class StackError(Exception):
    pass


class Stack:
    """
    A class that implements a stack using a singly linked list.
    """

    def __init__(self):
        self._top = None
        self._size = 0

    def peek(self):
        if self.is_empty():
            raise StackError("Peek from empty stack.")
        return self._top.data

    def push(self, item):
        new_node = Node(item)
        new_node.next = self._top
        self._top = new_node
        self._size += 1

    def pop(self):
        if self.is_empty():
            raise StackError("Pop from empty stack.")
        data = self._top.data
        self._top = self._top.next
        self._size -= 1
        return data

    def is_empty(self):
        return self._top is None

    def size(self):
        return self._size


class QueueError(Exception):
    pass


class Queue:
    """
    A class that implements a queue using a singly linked list with a tail.
    """

    def __init__(self):
        self._front = None
        self._rear = None
        self._size = 0

    def peek(self):
        if self.is_empty():
            raise QueueError("Peek from empty queue.")
        return self._front.data

    def enqueue(self, item):
        new_node = Node(item)
        if self.is_empty():
            self._front = new_node
        else:
            self._rear.next = new_node
        self._rear = new_node
        self._size += 1

    def dequeue(self):
        if self.is_empty():
            raise QueueError("Dequeue from empty queue.")
        data = self._front.data
        self._front = self._front.next
        if self._front is None:
            self._rear = None
        self._size -= 1
        return data

    def is_empty(self):
        return self._size == 0

    def size(self):
        return self._size


class ColoredVertex:
    """Class for a graph vertex."""

    def __init__(self, index, x, y, color):
        self.index = index
        self.x = x
        self.y = y
        self.color = color
        self.prev_color = color
        self.edges = []
        self.visited = False

    def add_edge(self, vertex_index):
        """Add an edge to another vertex index."""
        self.edges.append(vertex_index)

    def visit_and_set_color(self, new_color):
        """Mark this vertex visited and update its color."""
        self.visited = True
        self.prev_color = self.color
        self.color = new_color
        print(f"Visited vertex {self.index}")

    def __str__(self):
        return f"index: {self.index}, color: {self.color}, x: {self.x}, y: {self.y}"  


class ImageGraph:
    """Class for the graph representing the image."""

    def __init__(self, image_size):
        self.image_size = image_size
        self.vertices = []

    def print_image(self):
        """Print the current state of the image grid."""
        img = [["black"] * self.image_size for _ in range(self.image_size)]
        for v in self.vertices:
            img[v.y][v.x] = v.color
        for row in img:
            for pixel in row:
                print_block(pixel)
            print()
        print(RESET_CHAR)

    def reset_visited(self):
        """Reset the visited flag on all vertices."""
        for v in self.vertices:
            v.visited = False

    def create_adjacency_matrix(self):
        """
        Creates and returns the adjacency matrix for the graph.
        """
        n = len(self.vertices)
        matrix = [[0] * n for _ in range(n)]
        for v in self.vertices:
            for nei in v.edges:
                matrix[v.index][nei] = 1
        return matrix

    def bfs(self, start_index, new_color):
        """
        Bucket-fill via breadth-first search using a Queue.
        """
        self.reset_visited()
        original_color = self.vertices[start_index].color
        print("Starting BFS; initial state:")
        self.print_image()

        q = Queue()
        q.enqueue(start_index)
        while not q.is_empty():
            idx = q.dequeue()
            v = self.vertices[idx]
            if not v.visited and v.color == original_color:
                v.visit_and_set_color(new_color)
                self.print_image()
                for nei in v.edges:
                    w = self.vertices[nei]
                    if not w.visited and w.color == original_color:
                        q.enqueue(nei)

    def dfs(self, start_index, new_color):
        """
        Bucket-fill via depth-first search using a Stack.
        """
        self.reset_visited()
        original_color = self.vertices[start_index].color
        print("Starting DFS; initial state:")
        self.print_image()

        st = Stack()
        st.push(start_index)
        while not st.is_empty():
            idx = st.pop()
            v = self.vertices[idx]
            if not v.visited and v.color == original_color:
                v.visit_and_set_color(new_color)
                self.print_image()
                # Push neighbors in reverse so smallest index is processed first
                for nei in reversed(v.edges):
                    w = self.vertices[nei]
                    if not w.visited and w.color == original_color:
                        st.push(nei)


def create_graph(data):
    """
    Parse the input data (string) and build the ImageGraph,
    then return (graph, start_index, fill_color).
    """
    lines = [line.strip() for line in data.splitlines() if line.strip()]
    idx = 0
    size = int(lines[idx]); idx += 1
    graph = ImageGraph(size)

    # Read vertices
    num_vertices = int(lines[idx]); idx += 1
    for i in range(num_vertices):
        parts = [p.strip() for p in lines[idx].split(',')]
        x, y = int(parts[0]), int(parts[1])
        col = parts[2]
        graph.vertices.append(ColoredVertex(i, x, y, col))
        idx += 1

    # Read edges
    num_edges = int(lines[idx]); idx += 1
    for _ in range(num_edges):
        parts = [p.strip() for p in lines[idx].split(',')]
        a, b = int(parts[0]), int(parts[1])
        graph.vertices[a].add_edge(b)
        graph.vertices[b].add_edge(a)
        idx += 1

    # Read bucket-fill spec
    parts = [p.strip() for p in lines[idx].split(',')]
    start_index, fill_color = int(parts[0]), parts[1]
    return graph, start_index, fill_color


def main():
    # For manual testing; not used by the unit tests
    data = sys.stdin.read()
    graph, start, color = create_graph(data)
    mat = graph.create_adjacency_matrix()
    print("[")
    for row in mat:
        print(" " + str(row))
    print("]")
    graph.bfs(start, color)
    graph, start, color = create_graph(data)
    graph.dfs(start, color)


if __name__ == "__main__":
    main()
